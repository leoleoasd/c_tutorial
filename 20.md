# 蓝桥杯校内模拟赛题解-1

### 1. 在计算机存储中，15.125GB是多少MB？
#### 答案提交

这是一道结果填空的题，你只需要算出结果后提交即可。

答案: 15488

#### 解析: 

还要解析?????



### 2. 1200000有多少个约数（只计算正约数）。
#### 答案提交
这是一道结果填空的题，你只需要算出结果后提交即可。

答案: 96

#### 解析:

1. 暴力解法: 
```cpp
int ans = 0;
for(int i = 1; i <= 1200000; ++ i) {
    if(1200000 % i == 0) {
        ++i;
    }
}
```
2. 一般解法:
分解质因数, 得: 1200000 = 2^7*3*5^5.

约数个数为等于: 8*2*6 = 96.

### 3. 在1至2019中，有多少个数的数位中包含数字9？

注意，有的数中的数位中包含多个9，这个数只算一次。例如，1999这个数包含数字9，在计算只是算一个数。

答案: 544

#### 解析:
1. 快速解法:
```cpp
int ans = 0;
for(int i = 1; i <= 2019; ++ i){
    if(to_string(i).find("9") != string::npos){
        ans++;
    }
}
cout<<ans<<endl;
```
2. 一般解法:
```cpp
int ans = 0;
for(int i = 1; i <= 2019; ++ i){
    int now = i;
    while(now){
        if(now % 10 == 9){
            ans ++;
            break;
        }
        now /= 10;
    }
}
cout<<ans<<endl;
```

### 4. 一棵包含有2019个结点的树，最多包含多少个叶结点？

答案: 2018, 如果题目问的是二叉树就是1010.

#### 解析:
正常的树叶子节点最多显然2018个. 如果是二叉树, 为了保证叶子节点最多我们要使得每一个非叶子节点都有两个孩子. 显然, 一棵满二叉树满足这个条件. 

对于一个`2047`个节点的满二叉树, 共有`1024`个叶子节点, 我们**"成对的"**删去其中的`28`个之后, 正好剩余`2019`个节点. 删掉了`28`个叶子节点后, 他们的父节点也就成为了新的叶子节点, 因此叶子节点减少了`14`个. 答案就是`1024 - 14`.

**上述证明不严谨**

### 5. 问题描述

一个正整数如果任何一个数位不大于右边相邻的数位，则称为一个数位递增的数，例如1135是一个数位递增的数，而1024不是一个数位递增的数。

给定正整数 n，请问在整数 1 至 n 中有多少个数位递增的数？

#### 输入格式


输入的第一行包含一个整数 n。

#### 输出格式


输出一行包含一个整数，表示答案。

#### 样例输入
```
30
```
#### 样例输出
```
26
```
#### 评测用例规模与约定


对于 40% 的评测用例，1 <= n <= 1000。

对于 80% 的评测用例，1 <= n <= 100000。

对于所有评测用例，1 <= n <= 1000000。

#### 题解:
暴力即可, 时间复杂度为 O(n * log10(n)).

```cpp
int n = 0;
int ans = 0;
cin>>n;
for(int _ = 1; _ <= n; ++ _) {
    int i = _;
    int flag = 1;
    int last = i % 10;
    while(1){
        i /= 10;
        if(i == 0) {
            break;
        }
        if(last >= i % 10) {
            last = i % 10;
        }else{
            flag = 0;
            break;
        }
    }
    ans += flag;
}
cout<<ans<<endl;
```

### 6. 问题描述

小明对类似于 hello 这种单词非常感兴趣，这种单词可以正好分为四段，第一段由一个或多个辅音字母组成，第二段由一个或多个元音字母组成，第三段由一个或多个辅音字母组成，第四段由一个或多个元音字母组成。

给定一个单词，请判断这个单词是否也是这种单词，如果是请输出yes，否则请输出no。

元音字母包括 a, e, i, o, u，共五个，其他均为辅音字母。

#### 输入格式


输入一行，包含一个单词，单词中只包含小写英文字母。

#### 输出格式


输出答案，或者为yes，或者为no。

#### 样例输入1
```
lanqiao
```
#### 样例输出2
```
yes
```
#### 样例输入1
```
world
```
#### 样例输出2
```
no
```

#### 解析
暴力即可, 时间复杂度O(n).

```cpp
inline bool aeiou(char c) {
    return c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u';
}
int pos = 0;
int count = 0;
int size = str.size();
for (; pos < size; ++pos) {
    if (!aeiou(str[pos])) {
        count++;
    } else {
        break;
    }
}
if (count == 0) {
    cout << "no" << endl;
    return 0;
}
count = 0;
for (; pos < size; ++pos) {
    if (aeiou(str[pos])) {
        count++;
    } else {
        break;
    }
}
if (count == 0) {
    cout << "no" << endl;
    return 0;
}
count = 0;
for (; pos < size; ++pos) {
    if (!aeiou(str[pos])) {
        count++;
    } else {
        break;
    }
}
if (count == 0) {
    cout << "no" << endl;
    return 0;
}
count = 0;
for (; pos < size; ++pos) {
    if (aeiou(str[pos])) {
        count++;
    } else {
        break;
    }
}
if (count == 0) {
    cout << "no" << endl;
    return 0;
}
cout << "yes" << endl;
```

### 7. 问题描述

在数列 a[1], a[2], ..., a[n] 中，如果对于下标 i, j, k 满足 0<i<j<k<n+1 且 a[i]<a[j]<a[k]，则称 a[i], a[j], a[k] 为一组递增三元组，a[j]为递增三元组的中心。

给定一个数列，请问数列中有多少个元素可能是递增三元组的中心。

#### 输入格式


输入的第一行包含一个整数 n。

第二行包含 n 个整数 a[1], a[2], ..., a[n]，相邻的整数间用空格分隔，表示给定的数列。

#### 输出格式


输出一行包含一个整数，表示答案。

#### 样例输入
```
5
1 2 5 3 5
```
#### 样例输出
```
2
```
#### 样例说明


a[2] 和 a[4] 可能是三元组的中心。

#### 评测用例规模与约定


对于 50% 的评测用例，2 <= n <= 100，0 <= 数列中的数 <= 1000。

对于所有评测用例，2 <= n <= 1000，0 <= 数列中的数 <= 10000。

#### 题解
乍一看`1e5`还以为不能暴力, 结果一看`n`的范围是`1e3`, 果断暴力走起, 复杂度O(n^2).

```cpp
int n = 0;
int data[1010] = {0};
cin>>n;
for(int i = 0; i < n; ++ i){
    cin>>data[i];
}
int ans = 0;
for(int i = 0; i < n; ++ i) {
    int flag = 0;
    for(int j = i-1; j >= 0; -- j){
        if(data[j] < data[i]){
            flag += 1;
            break;
        }
    }
    for(int j = i+1; j < n; ++ j){
        if(data[j] > data[i]){
            flag += 1;
            break;
        }
    }
    ans += (flag == 2);
}
cout<<ans<<endl;
```