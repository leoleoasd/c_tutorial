# 变量在内存上

图

程序在运行的时候, 只关心变量的地址, 不关心变量的名字.

比如对于这样一行c语言代码:

```c
int bar = 1;
```

编译器会把它变成类似这样的汇编语言:

```asm
movl	$1, -4(%rbp)
```

这句话的意思是: 将`1`这个数字存储到内存上`-4(%rbp)`的地址中. `-4(%rbp)`指一个地址.
那么, 对于这句话以后的所有用到`bar`这个变量的地方, 编译器都会把`bar`替换为`-4(%rbp)`.

# 指针
指针存储的是变量的地址. 他可以**指向任意类型的变量**. 指针所占的空间大小与计算机有关, **64位电脑占用8个字节, 32位电脑占用4个字节**.

**指针 = 地址+类型**. 这句话什么意思呢? 举个例子:

```cpp
int *a = 0x100; // 0x开头表示这个数字是16进制表示
```

那么这种情况下, a指"从0x100开始的**长度为4个字节**的变量的地址". (int大小为4个字节)

假设内存中的值是这样的:

|值:|0x12|0x34|0x56|0x78|
|-|-|-|-|-|
|地址:|0x100|0x101|0x102|0x103|

那么对于一个int类型的指针: `int *a = 0x100;` 取值, 会得到:
```cpp
*a == 0x12345678;//从0x100开始的长度为4字节的值
```

对于一个char类型的指针: `char *b = 0x100;` 取值, 会得到:
```cpp
*b == 0x12;//从0x100开始的长度为1字节的值
```

同理, 对于一个short类型的指针: `short *c = 0x100;` 取值, 会得到:
```cpp
*c == 0x1234;//从0x100开始的长度为2字节的值
```

注: 以上均假设程序在运行在大端序的环境下, 如果你不知道啥是大端序请忽略.

重申: `指针=地址+类型`.

再比如, 对于指针的运算, 指针的类型也起到决定性作用. 众所周知, 对于以下代码:
```cpp
int data[100];
```
data是指向数组首元素的指针, data的值是数组首元素的地址.

data+1是指向数组第2个元素的指针, data+1的值是数组第二个元素的地址.

那么, 假设data=0x100, data+1等于多少?

显然, 一个int类型变量占用4个字节, data[0]占用了0x100, 0x101, 0x102, 0x103 这4个字节, 所以data+1应该等于0x104. 

这就体现了一个问题: 指针运算**需要知道指向的变量的大小**.

```cpp
int idata[10];
short sdata[10];
char cdata[10];
int iidata[10][4];

// 读作 一个名字叫做 iidata 的二维数组
// 它里面有 10 个一维数组
// 每个一维数组中有 4 个整型变量
// 数组的名字是指向数组中第一个元素的指针
// 对于二维数组，其中的第一个元素是它的第 0 个一维数组。
// 对于一维数组，其中的第一个元素是其中的第 0 个整型变量

printf("%p\n", idata);
printf("%p\n", idata + 1);
//会发现, idada+1 比 idata 大4

printf("%p\n", sdata);
printf("%p\n", sdata + 1);
//会发现, sdada+1 比 sdata 大2

printf("%p\n", cdata);
printf("%p\n", cdata + 1);
//会发现, cdada+1 比 cdata 大1

printf("%p\n", iidata);
printf("%p\n", iidata + 1);
// 会发现, iidada+1 比 iidata 16.
// iidata是一个二维数组, 也就是"数组的数组".
// iidata的元素是一维数组.
// 由于数组名字是指向数组首元素的指针,
// iidata是指向一个数组的指针, 数组的大小是 16 字节, 因此
// iidata+1比iidata大 16 字节.

```

# 无类型指针

```cpp
void* a = NULL;
```

`a`是一个无类型的指针. 因为没有类型, 所以不知道他的大小, 所以无法进行形如`a+1`的运算.
同样, 因为不知道类型, 也无法对这个指针"取值".

(c语言中, &运算符的作用是"从值取地址", *运算符的作用是"从地址取值".)

malloc函数的返回值是`void*`类型, 这点也很容易理解. **他不知道你申请的内存要存什么类型的数据**. 因此, 使用malloc时要进行**强制类型转换**:

```*
int *a = (int*)malloc(10*sizeof(int));
```

# 数组
数组就是指针. 数组的"维"**只改变根据下标计算元素地址时的行为**, 如:
```cpp
// 对于一维数组:
int data[100];
data + i == &(data[i]);
// 对于二维数组:
int data[50][100];
data + 100*i + j == &(data[i][j]);
       ^^^
       |||
//注意这里计算地址的时候用到了二维数组的列的数量
```
所以讲数组作为函数参数的时候:
```cpp
// 如果参数是一位数组:
int foo(int data[],int n);
// 这里不需要说明data的大小, 因为计算地址不需要大小.

//如果参数是二维数组:
int foo(int data[][100], int n);
// 这里必须说明data第二维的大小, 因为计算地址时需要知道data第二维的大小.
```

**重申: 数组维数只改变根据下表算地址的方式**. 无论几位数组都是指针, **二维数组不是指针的指针**.